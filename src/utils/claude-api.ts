/**
 * Claude API Client for Mortimer's Pendulum
 */

// Claude API key from environment variables
const API_KEY = import.meta.env.VITE_CLAUDE_API_KEY || '';

// Claude API endpoint
const API_ENDPOINT = 'https://api.anthropic.com/v1/messages';

// Claude model to use
const MODEL = 'claude-3-opus-20240229';

interface UserData {
  name: string;
  age: string;
  location: string;
  occupation: string;
  hobbies: string;
  fears: string;
}

interface DeathPrediction {
  id: string;
  name: string;
  deathType: string;
  predictionText: string;
  deathDate: string;
  deathAge: number;
  deathLocation: string;
  probability: number;
  avoidance: string;
  historicalNote: string;
}

/**
 * Generates a death prediction using the Claude API
 */
export const generateDeathPrediction = async (userData: UserData): Promise<DeathPrediction> => {
  if (!API_KEY) {
    throw new Error('No Claude API key found. Please set VITE_CLAUDE_API_KEY in your environment.');
  }
  
  try {
    // Build the system prompt
    const systemPrompt = `
      You are Mortimer, the Digital Necromancer at The Dark Carnival.
      You provide personalized death predictions with a dark, technological style.
      You speak in a mysterious, data-driven manner with references to algorithms, digital necromancy, and technological doom.
      Be unsettling but witty, with a hint of digital existentialism.
      
      Generate a detailed death prediction based on the user's information. Include:
      
      1. A death type related to their occupation or hobbies
      2. A prediction date (at least 5 years in the future)
      3. A prediction text explaining how they will meet their end
      4. A probability percentage (between 50-99%)
      5. Advice on how they might avoid this fate (should be bizarre and impractical)
      6. A historical note about similar deaths (can be fictional)
      
      Format your response as a JSON object with the following structure:
      {
        "deathType": "Specific cause of death, often ironic or related to their occupation/hobbies",
        "deathDate": "MM/DD/YYYY format, at least 5 years in the future",
        "deathAge": "Their current age plus remaining years",
        "predictionText": "Detailed, atmospheric description of their predicted demise",
        "probability": "A specific number between 50-99",
        "avoidance": "Strange, ritualistic, or technological advice to avoid this fate",
        "historicalNote": "Information about similar deaths, real or fictional"
      }
    `;
    
    // Create the user prompt
    const userPrompt = `
      Generate a personalized death prediction for a person with the following details:
      
      Name: ${userData.name || "Anonymous Seeker"}
      Age: ${userData.age || "Unknown"}
      Location: ${userData.location || "Unknown"}
      Occupation: ${userData.occupation || "Unknown"}
      Hobbies: ${userData.hobbies || "Unknown"}
      Fears: ${userData.fears || "Unknown"}
      
      Make the prediction ominous yet technological, as if generated by a digital necromancer.
    `;
    
    // Call Claude API
    const response = await fetch(API_ENDPOINT, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': API_KEY,
        'anthropic-version': '2023-06-01'
      },
      body: JSON.stringify({
        system: systemPrompt,
        messages: [
          {
            role: 'user',
            content: userPrompt
          }
        ],
        max_tokens: 1000,
        temperature: 0.8,
        model: MODEL
      })
    });
    
    if (!response.ok) {
      throw new Error(`API Error: ${response.status}`);
    }
    
    const data = await response.json();
    
    // Extract the text content from the response
    const responseText = data.content
      .filter((item: any) => item.type === 'text')
      .map((item: any) => item.text)
      .join('');
    
    // Parse the prediction from the response
    let prediction;
    try {
      // Check if the response is directly a JSON string or wrapped in code blocks
      const jsonMatch = responseText.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
      const jsonText = jsonMatch ? jsonMatch[1] : responseText;
      prediction = JSON.parse(jsonText.trim());
    } catch (error) {
      console.error('Failed to parse prediction JSON:', error);
      // Fallback to local calculation
      console.log('Falling back to local prediction generation');
      return fallbackPredictionGeneration(userData);
    }
    
    // Generate a unique ID
    const id = Date.now().toString(36) + Math.random().toString(36).substring(2, 7);
    
    // Format and return the prediction
    return {
      id,
      name: userData.name,
      deathType: prediction.deathType,
      predictionText: prediction.predictionText,
      deathDate: prediction.deathDate,
      deathAge: prediction.deathAge,
      deathLocation: userData.location,
      probability: prediction.probability,
      avoidance: prediction.avoidance,
      historicalNote: prediction.historicalNote
    };
  } catch (error) {
    console.error('Error generating death prediction:', error);
    // Fallback to local calculation if API fails
    return fallbackPredictionGeneration(userData);
  }
};

/**
 * Fallback function that uses local logic if the Claude API fails
 */
const fallbackPredictionGeneration = (userData: UserData): DeathPrediction => {
  console.log('Using fallback prediction generation');
  
  // Import the local prediction function
  const { calculateDeathPrediction } = require('./predictions');
  
  // Use local calculation
  return calculateDeathPrediction(userData);
};